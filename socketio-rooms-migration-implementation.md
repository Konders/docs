# Научный отчет: миграция WebSocket на Socket.IO rooms

## Аннотация
Документ фиксирует архитектурные изменения в WebSocket‑подсистеме, мотивы, сравнительный анализ поведения «было/стало», улучшения в безопасности и поддерживаемости, а также перечень тестовых кейсов. Цель — сохранить 100% бизнес‑логики старой реализации при переходе на нативные Socket.IO rooms и одновременно устранить архитектурные риски (ручное состояние, сложность сопровождения, «старые сокеты»).

## Методология и контекст
Исходная реализация в `src/unified-gateway/unified-gateway.service.ts` использовала in‑memory Map‑структуры для:
- регистрации подключенных клиентов (`connectedClients`),
- подписок на сущности (offer/balance/order),
- маршрутизации обновлений.

Новая версия переносит логику на нативные комнаты Socket.IO (rooms) и синхронизирует поведение с существующей бизнес‑логикой доступа.

## Ключевые изменения (по разделам)

### 1) Модель маршрутизации: Map → Rooms
**Было:** ручные структуры `Map` с явным контролем подписок и клиентских списков.  
**Стало:** rooms с предикатами `user:{id}`, `offer:{id}`, `balance:{id}`, `order:{id}`.

**Эффект:**
- исключены ошибки рассинхронизации (Map‑очистка и ручные баги);
- логика едина с нативными возможностями Socket.IO;
- упрощен масштабируемый broadcast (при наличии Redis adapter).

### 2) Подключение и идентификация пользователя
**Было:** `connectedClients` + `client.userId`.  
**Стало:** `client.data.userId` + `client.join(user:{id})`.

**Эффект:**
- унифицированный канал персональных сообщений;
- автоматическое управление подписками при disconnect.

### 3) Подписки на сущности (offer/balance/order)
**Было:** отдельные `Map` для offer/balance/order.  
**Стало:** join/leave в комнаты сущностей.

Пример:
```ts
await client.join(`balance:${cashboxId}`);
await client.leave(`balance:${cashboxId}`);
```

**Эффект:**
- упрощенная семантика подписок;
- меньше ручных состояний и сценариев утечек.

### 4) Рассылка уведомлений
**Было:** перебор массивов сокетов по userId.  
**Стало:** `server.to(room).emit(...)`.

Пример:
```ts
this.server.to(`user:${userId}`).emit('adminNotification', payload);
```

**Эффект:**
- более короткий и однозначный код;
- готовность к масштабированию (Redis adapter / sticky sessions).

### 5) Logout и «старые сокеты»
**Было:** `emit('logout')` без принудительного disconnect.  
**Стало:** `emit('logout')` + `disconnectSockets(true)` в room пользователя.

**Эффект:**
- гарантированное закрытие активных сокетов;
- устранение риска «залипших» соединений и повторной доставки.

### 6) Проверка доступа (безопасность)
**Было:** WebSocket‑подписки обходили HTTP‑guards; доступ к кассе не проверялся на WS‑уровне.  
**Стало:** в `requestOffer` и `subscribeBalance` добавлена проверка через бизнес‑метод `PermissionsService.getUserCashboxes(userId)`.

**Эффект:**
- закрыт канал для подписки на чужие кассы;
- WS‑доступ унифицирован с существующей бизнес‑логикой прав.

### 7) Cashier code: сохранение старого поведения
**Цель:** 100% эквивалентность старой логике.  
**Реализация:** если хотя бы один сокет пользователя подписан на `order:{id}`, обновления получают все его сокеты через `user:{id}`.

**Эффект:**
- поведение совпадает со старой системой;
- rooms используются как «триггер наличия подписки», а fan‑out делается по user‑room.

## Сравнение поведения (было/стало)

| Поток | Было | Стало | Эквивалентность |
|---|---|---|---|
| Подключение | Map `connectedClients` | `user:{id}` room | Да |
| Персональные уведомления | foreach clients | `server.to(user:{id})` | Да |
| Offer подписки | `userOfferAssociations` | `offer:{id}` room | Да |
| Balance подписки | `userBalanceSubscriptions` | `balance:{id}` room | Да |
| Cashier code | Map + broadcast на все сокеты пользователя | rooms + broadcast на все сокеты пользователя | Да |
| Logout | только emit | emit + disconnectSockets | Да, усилено |
| Доступ к кассам | не проверялся | проверяется через PermissionsService | Улучшено |

## Тестирование
Набор тестов в `src/unified-gateway/unified-gateway.service.spec.ts` покрывает 56 сценариев. Цели тестов:
1) Проверить корректность регистрации/подключения.  
2) Подтвердить правильность подписок и отписок по rooms.  
3) Проверить негативные сценарии (ошибки сервисов/permissions).  
4) Валидировать fan‑out для cashier code.  
5) Проверить правильную очистку соединений.

### Группы кейсов
- **Connection:** join user‑room, disconnect при invalid token, корректная регистрация обработчиков.
- **Offer:** отказ без прав, успешная подписка, обработка отсутствия оффера, ошибки поиска.
- **Finop:** успешная выдача и обработка ошибок.
- **Balance:** доступ/недоступ, join/leave, ошибки permissions/join/balance service.
- **Cashier code:** запрос/логout, error path, fan‑out на все сокеты пользователя, дедупликация по userId.
- **Notifications:** user/admin уведомления, пропуск при отсутствии сокетов, корректная сериализация user=null.
- **System events:** обработка `offerUpdated`, `accessRevoked`, `wsLogoutUser`.
- **Safety guards:** no‑op при `server` undefined.

## Результаты и итоговая оценка
- **Корректность бизнес‑логики:** 10/10 — поведение эквивалентно старой системе.  
- **Безопасность:** 9/10 — добавлены проверки прав и принудительный disconnect.  
- **Поддерживаемость:** 10/10 — исключены ручные Map‑структуры.  
- **Готовность к масштабированию:** 8/10 — rooms готовы, требуется Redis adapter или sticky sessions.

## Примечания по инфраструктуре
Rooms корректно работают в рамках одного инстанса. Для кросс‑инстанс рассылки нужен:
- **Redis adapter** (`@socket.io/redis-adapter`) или
- **sticky sessions** на балансировщике.

## Заключение
Миграция полностью воспроизводит старую бизнес‑логику, устраняет ручное состояние, повышает безопасность подписок и гарантирует корректный logout WebSocket‑сессий. Архитектура стала проще, предсказуемее и готова к горизонтальному масштабированию при подключении Redis adapter.
